<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Enterprise software development cycles - a subjective take | Vishnu Raghavan</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Enterprise software development cycles - a subjective take" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Entire books can be written about how software is developed in different organizations. Small startups usually operate very differently from large enterprises when it comes to developing, testing, and deploying software. Even among large companies, this changes based on whether it’s a company serving consumers directly or if they serve other businesses. This is to document my experiences working on enterprise software - software that is used by and sold to other businesses - over the last decade. What is enterprise software? Let’s start with the Wikipedia definition of this. Enterprise software is a collection of computer programs that have common business applications, tools for modeling how the entire organization works, and development tools for building applications unique to the organization. The software is intended to solve an enterprise-wide problem, rather than a departmental problem. Enterprise-level software aims to improve the enterprise’s productivity and efficiency by providing business logic support functionality. This involves software for, say, CRM, or large databases used by businesses, or software running on switches and routers in the internet backbone and the network edge, software for payment processing systems, mainframe systems, etc. This is very different from developing an iOS or Android application directly used by consumers or even consumer facing software from large firms such as Uber, Facebook(Meta?) or Netflix. I’m talking about companies like Oracle or Cisco or IBM. There are of course companies that fit in the middle of this spectrum. A prime example can be something like Stripe - which helps businesses of all sizes and shapes do e-commerce. Companies like Google and Amazon fit here as well since they do a mix of enterprise (AWS, Google Cloud, Ads) and consumer facing software (music, email, photos, payments). Among other reasons, here I see the barrier as thin, since the flow of ideas and people from one area to the other happens more freely. The culture and operating model for the business is still different enough from the large-enterprise focused companies such as Intel or Cisco. The software cycles are typically longer (months rather than weeks or days) and updates are released quarterly or (in some cases even annually). This is in contrast with companies like Uber, where software changes more frequently, sometimes daily and the companies pride themselves on this aspect of their culture (Uber Engineering’s Micro Deploy - this is from 2017, but I’d think still relevant). Let’s start with a look at the typical stakeholders in this process. Who are the stakeholders? The figure below represents a very high level representation of the process with the interested parties. Developers - These are the software engineers (including the software/product architects, leads, managers, etc.) who work on designing and developing the software in question. This usually includes multiple teams depending on the scope of the work involved. As is the case with large organizations working on software over a few years, the size of the code base is huge and multiple teams work on any single product/feature. So, anything other then simple features or bug fixes can be assumed to involve multiple teams. Anyone from UI/front-end/back-end engineering teams to embedded software engineers (or all of them for large products) fall into this bucket. For example, a product such as enterprise firewall can have the core software team for the firewall itself, a team working on the management layer for the firewall (say a security controller), a UI team for the management device, a policy team to maintain the consumer facing policy layer, etc. Testing engineers - This includes the engineers who take over from the development teams and run more extensive tests (outside of the unit-tests written by the developers). This includes end-to-end product testing, regression tests, automated test suites, functional and feature interaction tests. System vs solution tests Systems tests are meant to test the product as a whole (think QA/black box testing) and how different applications/software layers work together. Solution tests are meant to test the product/feature in the ecosystem similar to where it is deployed. If the product tested is a firewall, then the solution test team deploys it in an environment close to how it is deployed in customer premises (with the entire management/contol plane, variety of devices for traffic, with enough load/scale, etc). DevOps - This can mean a lot of things - build automation, test pipeline management, software deployment automation, artifact management, etc. Even GitHub automation for code commit management falls into this. UX designers - For features which have a management plane, UX designers are also part of the project. This is usually from dedicated UX teams who contribute to multiple products based on requirements and existing functionality. Product Management - This includes the product managers who focus on the technical aspects which need attention based on customer feedback and market needs. They do the market research to decide what features makes most business sense for the company/product in question and combine that with customer feedback for existing products to generate actionable feature requests for the development teams. Project Management - Distinct from product management, this category includes those working to manage projects involving multiple teams (sometimes across different sectors in the company) and taking it to completion. The project managers track the timelines and deliverables, prioritize and schedule tasks to achieve cross-functional development success. Technical Marketing/Sales - This sometimes has overlap with product management based on the company. But typically this includes teams working to take finished products/features to market them to customers, work on technical demonstrations, prepare field trials and to collect specific engineering feedback. Technical writers - This includes teams working on technical documentation for the product/features. They collect information from the development and testing teams and work on documenting it in such a way as to make it easier for others to then use the software. Software Release Management - This includes specialized teams working on managing software release cycles. This may sometimes be folded into DevOps. Customers - This is a term which can mean a lot, but in this case we’re looking at enterprise customers - i.e., large businesses which buy and use software. Examples - for a company like Intel which develops chip-sets, laptop manufacturers can be customers. For companies like Juniper Networks, large enterprises (like Walmart for their IT needs) or ISPs (AT&amp;T, Verizon) can be customers. These customer organizations have specific business needs which are translated into technical requirements which are then converted to finished products to be deployed back in the organizations. Software development cycle The figure in the previous section has a high level overview of the software lifecycle in terms of the teams involved. It shows the sequence of steps followed to get a product/feature requirement translated into a completed product. Let’s look at the ‘development’ phase in a little more detail. There are a few ways a project starts: Engineering driven innovations The Engineering teams (development/testing) recognizes the need for improvement in a product or a new product/feature category altogether and gets buy-in from the other teams to begin development in new software. This can be because the software leads/architects see a new way to do something, or improvements to existing products based on their deep knowledge of existing code bases, etc. However this is done, the push to start a new cycle is internal to the company and customer feedback is collected early in the cycle or at the end once a stable version of the software is available. Customer driven requirements The customers, depending on their operational needs, request a new feature or product category altogether (say a custom architecture of a chip-set to suit a new form factor, a new way to do user authentication across their internal network, etc.). This is then translated (by either the Sales teams if this is a new customer they are bidding to sign or by the product marketing teams for existing customers looking for new features) to engineering requirements to be taken up for development. This is put in a queue of features to be prioritized for every release and then taken up for development by the engineering teams. Competitor catch-up This needs to be said - not all companies are at the cutting edge of engineering developments, and sometimes they simply need to catch up to faster, nimbler competitors. Once the competitor comes up with a new architecture for their leading chip-sets (and, say, leading to more processing power or higher speeds), or a feature/product that obviates the need for an existing product category, the need to catch up to them drives the changes. There are several other reasons (such as acquisition of a smaller company and merging it into existing product lines, or security holes exposed by a vulnerability, etc.). But the above three are the more prominent ones. Once a need to start something new is seen, the different teams involved in this need to co-ordinate development. Each team may have their own prioritized list of tasks. But when cross-functional requirements are to be taken up, a software architect (titles vary across companies) runs the initial discussions to arrive at specific goals until project management takes over to drive the development. What about the methodology used for development? What we’ve explained so far fits neatly into the classic waterfall model of software development. Can development here be “Agile”? Waterfall or Agile? How about a hybrid? Again turning to Wikipedia, The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. The approach is typical for certain areas of engineering design. In software development, it tends to be among the less iterative and flexible approaches, as progress flows in largely one direction (“downwards” like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance. The months long development cycles have traditionally followed this waterfall model. The requirements and scope of development is decided months in advance and then once the development team has completed the features, the actual deployment of code is weeks to months (sometime years later for cautious enterprise customers) later. But this need not rule out the Agile approach. Turning to a different source this time Atlassian, Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a “big bang” launch, an agile team delivers work in small, but consumable, increments. Requirements, plans, and results are evaluated continuously so teams have a natural mechanism for responding to change quickly. This indicates an iterative development process with continuous and frequent feedback loops. In the enterprise development cycles, this can simply mean shorter internal cycles to develop and test code. That way a longer cycle to deploy code to customer premises can be combined with shorter internal cycles to streamline development processes. This hybrid approach helps to align long term strategy with shorter and faster cycles especially during cross-functional development. Different internal teams may have different priorities and approaches, but being “agile” and adaptable to change can mean quick realignment when there is a shift in priorities due to external factors. Recent shift to working from home is an example. Lots of companies needed to shift priorities. Lack of raw materials, new product areas (or de-prioritized existing products), reduced budgets - all this need not mean that a decision taken months ago ties everyone’s hands. The internal teams can quickly shift strategy with such a hybrid approach. As times change, internal processes change at such companies to be more like those at nimbler smaller companies and that changes the development culture for the better. Ignoring such changes are usually done at the company’s peril. Reacting faster to change has become a nessary trait at software companies due to the pace of change of the market. Companies like Microsoft have successfully made this change, at least in some segments of their business. Hope this helps provide some insights into operational processes at a certain kind of large companies." />
<meta property="og:description" content="Entire books can be written about how software is developed in different organizations. Small startups usually operate very differently from large enterprises when it comes to developing, testing, and deploying software. Even among large companies, this changes based on whether it’s a company serving consumers directly or if they serve other businesses. This is to document my experiences working on enterprise software - software that is used by and sold to other businesses - over the last decade. What is enterprise software? Let’s start with the Wikipedia definition of this. Enterprise software is a collection of computer programs that have common business applications, tools for modeling how the entire organization works, and development tools for building applications unique to the organization. The software is intended to solve an enterprise-wide problem, rather than a departmental problem. Enterprise-level software aims to improve the enterprise’s productivity and efficiency by providing business logic support functionality. This involves software for, say, CRM, or large databases used by businesses, or software running on switches and routers in the internet backbone and the network edge, software for payment processing systems, mainframe systems, etc. This is very different from developing an iOS or Android application directly used by consumers or even consumer facing software from large firms such as Uber, Facebook(Meta?) or Netflix. I’m talking about companies like Oracle or Cisco or IBM. There are of course companies that fit in the middle of this spectrum. A prime example can be something like Stripe - which helps businesses of all sizes and shapes do e-commerce. Companies like Google and Amazon fit here as well since they do a mix of enterprise (AWS, Google Cloud, Ads) and consumer facing software (music, email, photos, payments). Among other reasons, here I see the barrier as thin, since the flow of ideas and people from one area to the other happens more freely. The culture and operating model for the business is still different enough from the large-enterprise focused companies such as Intel or Cisco. The software cycles are typically longer (months rather than weeks or days) and updates are released quarterly or (in some cases even annually). This is in contrast with companies like Uber, where software changes more frequently, sometimes daily and the companies pride themselves on this aspect of their culture (Uber Engineering’s Micro Deploy - this is from 2017, but I’d think still relevant). Let’s start with a look at the typical stakeholders in this process. Who are the stakeholders? The figure below represents a very high level representation of the process with the interested parties. Developers - These are the software engineers (including the software/product architects, leads, managers, etc.) who work on designing and developing the software in question. This usually includes multiple teams depending on the scope of the work involved. As is the case with large organizations working on software over a few years, the size of the code base is huge and multiple teams work on any single product/feature. So, anything other then simple features or bug fixes can be assumed to involve multiple teams. Anyone from UI/front-end/back-end engineering teams to embedded software engineers (or all of them for large products) fall into this bucket. For example, a product such as enterprise firewall can have the core software team for the firewall itself, a team working on the management layer for the firewall (say a security controller), a UI team for the management device, a policy team to maintain the consumer facing policy layer, etc. Testing engineers - This includes the engineers who take over from the development teams and run more extensive tests (outside of the unit-tests written by the developers). This includes end-to-end product testing, regression tests, automated test suites, functional and feature interaction tests. System vs solution tests Systems tests are meant to test the product as a whole (think QA/black box testing) and how different applications/software layers work together. Solution tests are meant to test the product/feature in the ecosystem similar to where it is deployed. If the product tested is a firewall, then the solution test team deploys it in an environment close to how it is deployed in customer premises (with the entire management/contol plane, variety of devices for traffic, with enough load/scale, etc). DevOps - This can mean a lot of things - build automation, test pipeline management, software deployment automation, artifact management, etc. Even GitHub automation for code commit management falls into this. UX designers - For features which have a management plane, UX designers are also part of the project. This is usually from dedicated UX teams who contribute to multiple products based on requirements and existing functionality. Product Management - This includes the product managers who focus on the technical aspects which need attention based on customer feedback and market needs. They do the market research to decide what features makes most business sense for the company/product in question and combine that with customer feedback for existing products to generate actionable feature requests for the development teams. Project Management - Distinct from product management, this category includes those working to manage projects involving multiple teams (sometimes across different sectors in the company) and taking it to completion. The project managers track the timelines and deliverables, prioritize and schedule tasks to achieve cross-functional development success. Technical Marketing/Sales - This sometimes has overlap with product management based on the company. But typically this includes teams working to take finished products/features to market them to customers, work on technical demonstrations, prepare field trials and to collect specific engineering feedback. Technical writers - This includes teams working on technical documentation for the product/features. They collect information from the development and testing teams and work on documenting it in such a way as to make it easier for others to then use the software. Software Release Management - This includes specialized teams working on managing software release cycles. This may sometimes be folded into DevOps. Customers - This is a term which can mean a lot, but in this case we’re looking at enterprise customers - i.e., large businesses which buy and use software. Examples - for a company like Intel which develops chip-sets, laptop manufacturers can be customers. For companies like Juniper Networks, large enterprises (like Walmart for their IT needs) or ISPs (AT&amp;T, Verizon) can be customers. These customer organizations have specific business needs which are translated into technical requirements which are then converted to finished products to be deployed back in the organizations. Software development cycle The figure in the previous section has a high level overview of the software lifecycle in terms of the teams involved. It shows the sequence of steps followed to get a product/feature requirement translated into a completed product. Let’s look at the ‘development’ phase in a little more detail. There are a few ways a project starts: Engineering driven innovations The Engineering teams (development/testing) recognizes the need for improvement in a product or a new product/feature category altogether and gets buy-in from the other teams to begin development in new software. This can be because the software leads/architects see a new way to do something, or improvements to existing products based on their deep knowledge of existing code bases, etc. However this is done, the push to start a new cycle is internal to the company and customer feedback is collected early in the cycle or at the end once a stable version of the software is available. Customer driven requirements The customers, depending on their operational needs, request a new feature or product category altogether (say a custom architecture of a chip-set to suit a new form factor, a new way to do user authentication across their internal network, etc.). This is then translated (by either the Sales teams if this is a new customer they are bidding to sign or by the product marketing teams for existing customers looking for new features) to engineering requirements to be taken up for development. This is put in a queue of features to be prioritized for every release and then taken up for development by the engineering teams. Competitor catch-up This needs to be said - not all companies are at the cutting edge of engineering developments, and sometimes they simply need to catch up to faster, nimbler competitors. Once the competitor comes up with a new architecture for their leading chip-sets (and, say, leading to more processing power or higher speeds), or a feature/product that obviates the need for an existing product category, the need to catch up to them drives the changes. There are several other reasons (such as acquisition of a smaller company and merging it into existing product lines, or security holes exposed by a vulnerability, etc.). But the above three are the more prominent ones. Once a need to start something new is seen, the different teams involved in this need to co-ordinate development. Each team may have their own prioritized list of tasks. But when cross-functional requirements are to be taken up, a software architect (titles vary across companies) runs the initial discussions to arrive at specific goals until project management takes over to drive the development. What about the methodology used for development? What we’ve explained so far fits neatly into the classic waterfall model of software development. Can development here be “Agile”? Waterfall or Agile? How about a hybrid? Again turning to Wikipedia, The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. The approach is typical for certain areas of engineering design. In software development, it tends to be among the less iterative and flexible approaches, as progress flows in largely one direction (“downwards” like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance. The months long development cycles have traditionally followed this waterfall model. The requirements and scope of development is decided months in advance and then once the development team has completed the features, the actual deployment of code is weeks to months (sometime years later for cautious enterprise customers) later. But this need not rule out the Agile approach. Turning to a different source this time Atlassian, Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a “big bang” launch, an agile team delivers work in small, but consumable, increments. Requirements, plans, and results are evaluated continuously so teams have a natural mechanism for responding to change quickly. This indicates an iterative development process with continuous and frequent feedback loops. In the enterprise development cycles, this can simply mean shorter internal cycles to develop and test code. That way a longer cycle to deploy code to customer premises can be combined with shorter internal cycles to streamline development processes. This hybrid approach helps to align long term strategy with shorter and faster cycles especially during cross-functional development. Different internal teams may have different priorities and approaches, but being “agile” and adaptable to change can mean quick realignment when there is a shift in priorities due to external factors. Recent shift to working from home is an example. Lots of companies needed to shift priorities. Lack of raw materials, new product areas (or de-prioritized existing products), reduced budgets - all this need not mean that a decision taken months ago ties everyone’s hands. The internal teams can quickly shift strategy with such a hybrid approach. As times change, internal processes change at such companies to be more like those at nimbler smaller companies and that changes the development culture for the better. Ignoring such changes are usually done at the company’s peril. Reacting faster to change has become a nessary trait at software companies due to the pace of change of the market. Companies like Microsoft have successfully made this change, at least in some segments of their business. Hope this helps provide some insights into operational processes at a certain kind of large companies." />
<link rel="canonical" href="/blog/2022/03/15/enterprise-software-cycles.html" />
<meta property="og:url" content="/blog/2022/03/15/enterprise-software-cycles.html" />
<meta property="og:site_name" content="Vishnu Raghavan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-15T09:21:30-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Enterprise software development cycles - a subjective take" />
<script type="application/ld+json">
{"datePublished":"2022-03-15T09:21:30-07:00","url":"/blog/2022/03/15/enterprise-software-cycles.html","dateModified":"2022-03-15T09:21:30-07:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/03/15/enterprise-software-cycles.html"},"description":"Entire books can be written about how software is developed in different organizations. Small startups usually operate very differently from large enterprises when it comes to developing, testing, and deploying software. Even among large companies, this changes based on whether it’s a company serving consumers directly or if they serve other businesses. This is to document my experiences working on enterprise software - software that is used by and sold to other businesses - over the last decade. What is enterprise software? Let’s start with the Wikipedia definition of this. Enterprise software is a collection of computer programs that have common business applications, tools for modeling how the entire organization works, and development tools for building applications unique to the organization. The software is intended to solve an enterprise-wide problem, rather than a departmental problem. Enterprise-level software aims to improve the enterprise’s productivity and efficiency by providing business logic support functionality. This involves software for, say, CRM, or large databases used by businesses, or software running on switches and routers in the internet backbone and the network edge, software for payment processing systems, mainframe systems, etc. This is very different from developing an iOS or Android application directly used by consumers or even consumer facing software from large firms such as Uber, Facebook(Meta?) or Netflix. I’m talking about companies like Oracle or Cisco or IBM. There are of course companies that fit in the middle of this spectrum. A prime example can be something like Stripe - which helps businesses of all sizes and shapes do e-commerce. Companies like Google and Amazon fit here as well since they do a mix of enterprise (AWS, Google Cloud, Ads) and consumer facing software (music, email, photos, payments). Among other reasons, here I see the barrier as thin, since the flow of ideas and people from one area to the other happens more freely. The culture and operating model for the business is still different enough from the large-enterprise focused companies such as Intel or Cisco. The software cycles are typically longer (months rather than weeks or days) and updates are released quarterly or (in some cases even annually). This is in contrast with companies like Uber, where software changes more frequently, sometimes daily and the companies pride themselves on this aspect of their culture (Uber Engineering’s Micro Deploy - this is from 2017, but I’d think still relevant). Let’s start with a look at the typical stakeholders in this process. Who are the stakeholders? The figure below represents a very high level representation of the process with the interested parties. Developers - These are the software engineers (including the software/product architects, leads, managers, etc.) who work on designing and developing the software in question. This usually includes multiple teams depending on the scope of the work involved. As is the case with large organizations working on software over a few years, the size of the code base is huge and multiple teams work on any single product/feature. So, anything other then simple features or bug fixes can be assumed to involve multiple teams. Anyone from UI/front-end/back-end engineering teams to embedded software engineers (or all of them for large products) fall into this bucket. For example, a product such as enterprise firewall can have the core software team for the firewall itself, a team working on the management layer for the firewall (say a security controller), a UI team for the management device, a policy team to maintain the consumer facing policy layer, etc. Testing engineers - This includes the engineers who take over from the development teams and run more extensive tests (outside of the unit-tests written by the developers). This includes end-to-end product testing, regression tests, automated test suites, functional and feature interaction tests. System vs solution tests Systems tests are meant to test the product as a whole (think QA/black box testing) and how different applications/software layers work together. Solution tests are meant to test the product/feature in the ecosystem similar to where it is deployed. If the product tested is a firewall, then the solution test team deploys it in an environment close to how it is deployed in customer premises (with the entire management/contol plane, variety of devices for traffic, with enough load/scale, etc). DevOps - This can mean a lot of things - build automation, test pipeline management, software deployment automation, artifact management, etc. Even GitHub automation for code commit management falls into this. UX designers - For features which have a management plane, UX designers are also part of the project. This is usually from dedicated UX teams who contribute to multiple products based on requirements and existing functionality. Product Management - This includes the product managers who focus on the technical aspects which need attention based on customer feedback and market needs. They do the market research to decide what features makes most business sense for the company/product in question and combine that with customer feedback for existing products to generate actionable feature requests for the development teams. Project Management - Distinct from product management, this category includes those working to manage projects involving multiple teams (sometimes across different sectors in the company) and taking it to completion. The project managers track the timelines and deliverables, prioritize and schedule tasks to achieve cross-functional development success. Technical Marketing/Sales - This sometimes has overlap with product management based on the company. But typically this includes teams working to take finished products/features to market them to customers, work on technical demonstrations, prepare field trials and to collect specific engineering feedback. Technical writers - This includes teams working on technical documentation for the product/features. They collect information from the development and testing teams and work on documenting it in such a way as to make it easier for others to then use the software. Software Release Management - This includes specialized teams working on managing software release cycles. This may sometimes be folded into DevOps. Customers - This is a term which can mean a lot, but in this case we’re looking at enterprise customers - i.e., large businesses which buy and use software. Examples - for a company like Intel which develops chip-sets, laptop manufacturers can be customers. For companies like Juniper Networks, large enterprises (like Walmart for their IT needs) or ISPs (AT&amp;T, Verizon) can be customers. These customer organizations have specific business needs which are translated into technical requirements which are then converted to finished products to be deployed back in the organizations. Software development cycle The figure in the previous section has a high level overview of the software lifecycle in terms of the teams involved. It shows the sequence of steps followed to get a product/feature requirement translated into a completed product. Let’s look at the ‘development’ phase in a little more detail. There are a few ways a project starts: Engineering driven innovations The Engineering teams (development/testing) recognizes the need for improvement in a product or a new product/feature category altogether and gets buy-in from the other teams to begin development in new software. This can be because the software leads/architects see a new way to do something, or improvements to existing products based on their deep knowledge of existing code bases, etc. However this is done, the push to start a new cycle is internal to the company and customer feedback is collected early in the cycle or at the end once a stable version of the software is available. Customer driven requirements The customers, depending on their operational needs, request a new feature or product category altogether (say a custom architecture of a chip-set to suit a new form factor, a new way to do user authentication across their internal network, etc.). This is then translated (by either the Sales teams if this is a new customer they are bidding to sign or by the product marketing teams for existing customers looking for new features) to engineering requirements to be taken up for development. This is put in a queue of features to be prioritized for every release and then taken up for development by the engineering teams. Competitor catch-up This needs to be said - not all companies are at the cutting edge of engineering developments, and sometimes they simply need to catch up to faster, nimbler competitors. Once the competitor comes up with a new architecture for their leading chip-sets (and, say, leading to more processing power or higher speeds), or a feature/product that obviates the need for an existing product category, the need to catch up to them drives the changes. There are several other reasons (such as acquisition of a smaller company and merging it into existing product lines, or security holes exposed by a vulnerability, etc.). But the above three are the more prominent ones. Once a need to start something new is seen, the different teams involved in this need to co-ordinate development. Each team may have their own prioritized list of tasks. But when cross-functional requirements are to be taken up, a software architect (titles vary across companies) runs the initial discussions to arrive at specific goals until project management takes over to drive the development. What about the methodology used for development? What we’ve explained so far fits neatly into the classic waterfall model of software development. Can development here be “Agile”? Waterfall or Agile? How about a hybrid? Again turning to Wikipedia, The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. The approach is typical for certain areas of engineering design. In software development, it tends to be among the less iterative and flexible approaches, as progress flows in largely one direction (“downwards” like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance. The months long development cycles have traditionally followed this waterfall model. The requirements and scope of development is decided months in advance and then once the development team has completed the features, the actual deployment of code is weeks to months (sometime years later for cautious enterprise customers) later. But this need not rule out the Agile approach. Turning to a different source this time Atlassian, Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a “big bang” launch, an agile team delivers work in small, but consumable, increments. Requirements, plans, and results are evaluated continuously so teams have a natural mechanism for responding to change quickly. This indicates an iterative development process with continuous and frequent feedback loops. In the enterprise development cycles, this can simply mean shorter internal cycles to develop and test code. That way a longer cycle to deploy code to customer premises can be combined with shorter internal cycles to streamline development processes. This hybrid approach helps to align long term strategy with shorter and faster cycles especially during cross-functional development. Different internal teams may have different priorities and approaches, but being “agile” and adaptable to change can mean quick realignment when there is a shift in priorities due to external factors. Recent shift to working from home is an example. Lots of companies needed to shift priorities. Lack of raw materials, new product areas (or de-prioritized existing products), reduced budgets - all this need not mean that a decision taken months ago ties everyone’s hands. The internal teams can quickly shift strategy with such a hybrid approach. As times change, internal processes change at such companies to be more like those at nimbler smaller companies and that changes the development culture for the better. Ignoring such changes are usually done at the company’s peril. Reacting faster to change has become a nessary trait at software companies due to the pace of change of the market. Companies like Microsoft have successfully made this change, at least in some segments of their business. Hope this helps provide some insights into operational processes at a certain kind of large companies.","headline":"Enterprise software development cycles - a subjective take","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Vishnu Raghavan" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Vishnu Raghavan</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Blog</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Enterprise software development cycles - a subjective take</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-03-15T09:21:30-07:00" itemprop="datePublished">Mar 15, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Entire books can be written about how software is developed in different organizations. Small startups usually operate very differently from large enterprises when it comes to developing, testing, and deploying software. Even among large companies, this changes based on whether it’s a company serving consumers directly or if they serve other businesses. This is to document my experiences working on enterprise software - software that is used by and sold to other businesses - over the last decade.</p>

<h2 id="what-is-enterprise-software">What is enterprise software?</h2>

<p>Let’s start with the Wikipedia definition of this.</p>

<blockquote>
  <p>Enterprise software is a collection of computer programs that have common business applications, tools for modeling how the entire organization works, and development tools for building applications unique to the organization. The software is intended to solve an enterprise-wide problem, rather than a departmental problem. Enterprise-level software aims to improve the enterprise’s productivity and efficiency by providing business logic support functionality.</p>
</blockquote>

<p>This involves software for, say, CRM, or large databases used by businesses, or software running on switches and routers in the internet backbone and the network edge, software for payment processing systems, mainframe systems, etc. This is very different from developing an iOS or Android application directly used by consumers or even consumer facing software from large firms such as Uber, Facebook(Meta?) or Netflix. I’m talking about companies like Oracle or Cisco or IBM.</p>

<p><img src="/assets/software-companies-spectrum.webp" alt="Software companies spectrum" /></p>

<p>There are of course companies that fit in the middle of this spectrum. A prime example can be something like Stripe - which helps businesses of all sizes and shapes do e-commerce. Companies like Google and Amazon fit here as well since they do a mix of enterprise (AWS, Google Cloud, Ads) and consumer facing software (music, email, photos, payments). Among other reasons, here I see the barrier as thin, since the flow of ideas and people from one area to the other happens more freely. The culture and operating model for the business is still different enough from the large-enterprise focused companies such as Intel or Cisco.</p>

<p>The software cycles are typically longer (months rather than weeks or days) and updates are released quarterly or (in some cases even annually). This is in contrast with companies like Uber, where software changes more frequently, sometimes daily and the companies pride themselves on this aspect of their culture (<a href="https://eng.uber.com/micro-deploy-code/">Uber Engineering’s Micro Deploy</a> - this is from 2017, but I’d think still relevant).</p>

<p>Let’s start with a look at the typical stakeholders in this process.</p>

<h2 id="who-are-the-stakeholders">Who are the stakeholders?</h2>

<p>The figure below represents a very high level representation of the process with the interested parties.</p>

<p><img src="/assets/software-cycle-enterprise.webp" alt="Software development cycle" /></p>

<ul>
  <li><strong>Developers</strong> - These are the software engineers (including the software/product architects, leads, managers, etc.) who work on designing and developing the software in question. This usually includes multiple teams depending on the scope of the work involved. As is the case with large organizations working on software over a few years, the size of the code base is huge and multiple teams work on any single product/feature. So, anything other then simple features or bug fixes can be assumed to involve multiple teams. Anyone from UI/front-end/back-end engineering teams to embedded software engineers (or all of them for large products) fall into this bucket.
    <ul>
      <li>For example, a product such as enterprise firewall can have the core software team for the firewall itself, a team working on the management layer for the firewall (say a security controller), a UI team for the management device, a policy team to maintain the consumer facing policy layer, etc.</li>
    </ul>
  </li>
  <li><strong>Testing engineers</strong> - This includes the engineers who take over from the development teams and run more extensive tests (outside of the unit-tests written by the developers). This includes end-to-end product testing, regression tests, automated test suites, functional and feature interaction tests.
    <ul>
      <li>System vs solution tests
        <ul>
          <li>Systems tests are meant to test the product as a whole (think QA/black box testing) and how different applications/software layers work together.</li>
          <li>Solution tests are meant to test the product/feature in the ecosystem similar to where it is deployed. If the product tested is a firewall, then the solution test team deploys it in an environment close to how it is deployed in customer premises (with the entire management/contol plane, variety of devices for traffic, with enough load/scale, etc).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>DevOps</strong> - This can mean a lot of things - build automation, test pipeline management, software deployment automation, artifact management, etc. Even GitHub automation for code commit management falls into this.</li>
  <li><strong>UX designers</strong> - For features which have a management plane, UX designers are also part of the project. This is usually from dedicated UX teams who contribute to multiple products based on requirements and existing functionality.</li>
  <li><strong>Product Management</strong> - This includes the product managers who focus on the technical aspects which need attention based on customer feedback and market needs. They do the market research to decide what features makes most business sense for the company/product in question and combine that with customer feedback for existing products to generate actionable feature requests for the development teams.</li>
  <li><strong>Project Management</strong> - Distinct from product management, this category includes those working to manage projects involving multiple teams (sometimes across different sectors in the company) and taking it to completion. The project managers track the timelines and deliverables, prioritize and schedule tasks to achieve cross-functional development success.</li>
  <li><strong>Technical Marketing/Sales</strong> - This sometimes has overlap with product management based on the company. But typically this includes teams working to take finished products/features to market them to customers, work on technical demonstrations, prepare field trials and to collect specific engineering feedback.</li>
  <li><strong>Technical writers</strong> - This includes teams working on technical documentation for the product/features. They collect information from the development and testing teams and work on documenting it in such a way as to make it easier for others to then use the software.</li>
  <li><strong>Software Release Management</strong> - This includes specialized teams working on managing software release cycles. This may sometimes be folded into DevOps.</li>
  <li><strong>Customers</strong> - This is a term which can mean a lot, but in this case we’re looking at enterprise customers - i.e., large businesses which buy and use software. Examples - for a company like Intel which develops chip-sets, laptop manufacturers can be customers. For companies like Juniper Networks, large enterprises (like Walmart for their IT needs) or ISPs (AT&amp;T, Verizon) can be customers. These customer organizations have specific business needs which are translated into technical requirements which are then converted to finished products to be deployed back in the organizations.</li>
</ul>

<h2 id="software-development-cycle">Software development cycle</h2>

<p>The figure in the previous section has a high level overview of the software lifecycle in terms of the teams involved. It shows the sequence of steps followed to get a product/feature requirement translated into a completed product.</p>

<p>Let’s look at the ‘development’ phase in a little more detail. There are a few ways a project starts:</p>

<ol>
  <li>
    <p>Engineering driven innovations</p>

    <p>The Engineering teams (development/testing) recognizes the need for improvement in a product or a new product/feature category altogether and gets buy-in from the other teams to begin development in new software. This can be because the software leads/architects see a new way to do something, or improvements to existing products based on their deep knowledge of existing code bases, etc. However this is done, the push to start a new cycle is internal to the company and customer feedback is collected early in the cycle or at the end once a stable version of the software is available.</p>
  </li>
  <li>
    <p>Customer driven requirements</p>

    <p>The customers, depending on their operational needs, request a new feature or product category altogether (say a custom architecture of a chip-set to suit a new form factor, a new way to do user authentication across their internal network, etc.). This is then translated (by either the Sales teams if this is a new customer they are bidding to sign or by the product marketing teams for existing customers looking for new features) to engineering requirements to be taken up for development. This is put in a queue of features to be prioritized for every release and then taken up for development by the engineering teams.</p>
  </li>
  <li>
    <p>Competitor catch-up</p>

    <p>This needs to be said - not all companies are at the cutting edge of engineering developments, and sometimes they simply need to catch up to faster, nimbler competitors. Once the competitor comes up with a new architecture for their leading chip-sets (and, say, leading to more processing power or higher speeds), or a feature/product that obviates the need for an existing product category, the need to catch up to them drives the changes.</p>
  </li>
</ol>

<p>There are several other reasons (such as acquisition of a smaller company and merging it into existing product lines, or security holes exposed by a vulnerability, etc.). But the above three are the more prominent ones.</p>

<p>Once a need to start something new is seen, the different teams involved in this need to co-ordinate development. Each team may have their own prioritized list of tasks. But when cross-functional requirements are to be taken up, a software architect (titles vary across companies) runs the initial discussions to arrive at specific goals until project management takes over to drive the development. What about the methodology used for development? What we’ve explained so far fits neatly into the classic waterfall model of software development. Can development here be “Agile”?</p>

<h2 id="waterfall-or-agile-how-about-a-hybrid">Waterfall or Agile? How about a hybrid?</h2>

<p>Again turning to Wikipedia,</p>

<blockquote>
  <p>The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialization of tasks. The approach is typical for certain areas of engineering design. In software development, it tends to be among the less iterative and flexible approaches, as progress flows in largely one direction (“downwards” like a waterfall) through the phases of conception, initiation, analysis, design, construction, testing, deployment and maintenance.</p>
</blockquote>

<p>The months long development cycles have traditionally followed this waterfall model. The requirements and scope of development is decided months in advance and then once the development team has completed the features, the actual deployment of code is weeks to months (sometime years later for cautious enterprise customers) later. But this need not rule out the Agile approach.</p>

<p>Turning to a different source this time <a href="https://www.atlassian.com/agile">Atlassian</a>,</p>
<blockquote>
  <p>Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a “big bang” launch, an agile team delivers work in small, but consumable, increments. Requirements, plans, and results are evaluated continuously so teams have a natural mechanism for responding to change quickly.</p>
</blockquote>

<p>This indicates an iterative development process with continuous and frequent feedback loops. In the enterprise development cycles, this can simply mean shorter internal cycles to develop and test code. That way a longer cycle to deploy code to customer premises can be combined with shorter internal cycles to streamline development processes.</p>

<p>This hybrid approach helps to align long term strategy with shorter and faster cycles especially during cross-functional development. Different internal teams may have different priorities and approaches, but being “agile” and adaptable to change can mean quick realignment when there is a shift in priorities due to external factors.</p>

<p>Recent shift to working from home is an example. Lots of companies needed to shift priorities. Lack of raw materials, new product areas (or de-prioritized existing products), reduced budgets - all this need not mean that a decision taken months ago ties everyone’s hands. The internal teams can quickly shift strategy with such a hybrid approach.</p>

<p>As times change, internal processes change at such companies to be more like those at nimbler smaller companies and that changes the development culture for the better. Ignoring such changes are usually done at the company’s peril. Reacting faster to change has become a nessary trait at software companies due to the pace of change of the market. Companies like Microsoft have successfully made this change, at least in some segments of their business.</p>

<p>Hope this helps provide some insights into operational processes at a certain kind of large companies.</p>

  </div><a class="u-url" href="/blog/2022/03/15/enterprise-software-cycles.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Vishnu Raghavan</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Vishnu Raghavan</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rvishpr"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">rvishpr</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Capturing my thoughts on things I learn or whatever has captured my attention recently.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
