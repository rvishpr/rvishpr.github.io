<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Introduction to Dynamic Programming! | Vishnu Raghavan</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Introduction to Dynamic Programming!" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Overview Not many who have left school use concepts such as Dynamic Programming on a day to day basis. Most only to come to them when preparing for an interview. However, this is a useful algorithmic technique and it helps to understand it. This post should provide an introduction to Dynamic Programming and after reading this, it should be possible to attempt the problems provided at the end with ease. Dynamic programming (or dynamic optimization) is a method for solving problems which can split into multiple simpler, smaller and overlapping (or repeating) sub-problems. Since the sub-problems are overlapping (meaning same sub-problems get repeated several times), it will be possible to save the solutions to them in a memory-based data structure. This helps reduce computation time at the expense of (hopefully moderate) storage space. Each of the sub-problem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. The technique of storing solutions to sub-problems instead of recomputing them is called Memoization. The two main requirements for a problem to be solved this way are Optimal Substructure and Overlapping sub-problems. Optimal Substructure This simply means that the optimal solution to the actual problem is a combination of the optimal solutions to its sub-problems. This will become clearer as we look at Examples, but a quick look at Dijkstra’s algorithm for single-source shortest path computation will help us understand this. In that, we repeatedly compute the shortest so-far from a source, by storing the vertices in a priority queue, weighted by their distance from the source. So the shortest distance from a node s to a node n will be d(s,n) = d(s,m) + e(m,n) where e(m,n) is the length of the edge from m to n. In this case, the optimal substructure is that the shortest distance from s to n is the shortest distance from s to m + the edge from m to n. Recursion plays a big role in visualizing these problems and is usually the first approach to solving such problems. Overlapping Sub-Problems This requirement needs the problem to be split into a small space of sub-problems which would be solved over and over again in the process of getting to the solution of the problem — ie., we should be solving the same problems over and over again instead of solving newer and newer sub-problems. An example of non-overlapping subproblems is the merge-sort (and quicksort). Merge sort falls into the Divide and Conquer category, since we solve distinct subproblems and repeatedly merge the results. Example: To calculate Fibonacci numbers, fib(4) = fib(3) + fib(2) and fib(3) = fib(2) + fib(1) and so on. For each higher number in the series, if we solve this recursively, we will end up calculating the same lower-order problems over and over again. Such is a requirement for the problem to fall into this category. Memoization If the above two requirements are met, then we can save or cache the results to be looked up later when we are solving the same sub-problems again and again. This will result in a huge drop in computation times at the expence of a small increase in memory space consumption. For example, in the fibonacci series problem, when calculating fib(4), we need fib(3) and fib(2). But, fib(3) = fib(2) + fib(1). So fib(2) could be calculated twice here. If we cache fib(2) the first time it is calculated and then re-use it, this optimizes the computation. This is memoization. Solving the Problem There are two approaches to solving such problems — the top-down approach and the bottom-up approach. Top-down approach This directly results from the recursion &amp; memoization principles. We start from the problem and recursively solve the sub-problems while caching the results. Example: for fibonacci series, to get fib(50) - the 50th number in the series, we will calculate fib(49) and fib(48) and for fib(49), we’ll calculate fib(48) and fib(47) and so on recursively. If we think about this, then we can see that the first actual computation per se will be to compute the edge cases fib(0) and fib(1) and then fib(2) and so on until we get to fib(49) and fib(48). We recursively compute the smaller problems optimally and cache the results. This directly leads to the next approach. Bottom-up approach In this approach, we start from a base case and iteratively build up to the solution we are looking for. Instead of recursively solving the problem, we formulate the sub problems, and solve them first before using them to build a solution for the problem itself. It’s usually a table that stores the data needed with the indices somehow referring to the parameters of the problem itself. Taking the same example of Fibonacci numbers, if we need fib(50), we start at fib(0) and fib(1) as our base cases, and iteratively build the solutions to bigger problems from them to get to fib(50). Examples The key to solving these problems is identifying the recurrence correctly and what the table actually represents. Once that is done, formulating the table is trivial. Fibonacci numbers A good example is calculating Fibonacci numbers. fib(n) = fib(n-1) + fib(n-2). A recursive approach to solving this would be: func fibonacci(num int) int { if num == 0 || num == 1 { return 1 } return fibonacci(num - 1) + fibonacci(num - 2) } We can see the calls to sub-problems will quickly explode computing the same problems over and over again, especially the smaller sub-problems — fib(2), fib(1), fib(0). To avoid this, we could cache the solution. func fibonacci(num int, cache map[int]int) int { if num == 0 || num == 1 { // base case return num } result := 0 if result, ok := cache[num]; ok { return result } result = fibonacci(num - 1, cache) + fibonacci(num - 2, cache) cache[num] = result return result } We now store the solution and then use it if needed without having to recompute the sub-problems again. This leads to out next optimization where we start from the bottom-up. func fibonacci(num int) int { // base cases num1 := 0 num2 := 1 fib := 0 for i := 2; i &lt;= num; i++ { fib = num1 + num2 num1 = num2 num2 = fib } return fib } Coin change problems There are two coin change problems. The two seem similar, but are subtly different. Given an amount and a list of coin values (each with infinite coins), find out in how many ways we can make change for the amount. When we have n coins, we need to count the number of ways we can make change with all combination of coins. Say we have [1,2,5], we need to find out in how many ways we make change with [1], [2], [5] [1,2], [1,5], [2,5], [1,2,5]. But counting this way is not efficient. So we look at this problem another way. Each time we either use a coin or we don’t and then we count the number of ways and then we sum them up. ie., fn(Amount, coins[1...n]) = fn(Amount - coin[n], coins[1...n]] + fn(Amount, coins[1...n-1]) This way, we get all combination of coins. Not intuitive right away, but makes sense if we think about it. This leads to the following solution. func change(amount int, coins []int) int { if amount &lt; 0 { return 0 } if amount == 0 { return 1 } if len(coins) == 0 { return 0 } length := len(coins) return change(amount, coins[:length-1]) + change(amount - coins[length-1], coins) } The top-down approach will be trivial. We simply need to cache the solution for [amount][len(coins))]. The bottom up approach is more interesting. func change(amount int, coins []int) int { cache := make([][]int, amount+1) for i := 0; i &lt;= amount; i++ { cache[i] = make([]int, len(coins) + 1) } for i := 0; i &lt;= len(coins); i++ { cache[0][i] = 1 } for i := 1; i &lt;= len(coins); i++ { for j := 1; j &lt;= amount; j++ { if j - coins[i-1] &gt;= 0 { //cached optimal sub-problem solution cache[j][i] = cache[j - coins[i-1]][i] } cache[j][i] = cache[j][i] + cache[j][i-1] } } return cache[amount][len(coins)] } Given an amount and a list of coin values (each with infinite coins), find out the minimum number of coins with which we can make change for the amount. This problem can’t be solved by looking at it like we did for the previous problem. We don’t need all combinations of change-making. We only need one — the minimum #coins that can make the change. The subproblem here is that at each point, we use the best coin and then try and find the minimum number of coins required to change the remaining amount with ALL coins. This means we can’t take the approach as in the previous variety, where we can use any coin. If V is the amount to be changed, and there are n coins, the recursion here can be represented by If V == 0, 0 coins are needed. If V &gt; 0 { minCoins(coins[0...n-1], V) = min {1 + minCoins(coins[0...n-1], V - coins[i])} where V &gt; coins[i] &amp;&amp; i varies from 0...m-1. } The simple recursion approach will work by just calling the above. The top-down approach will work by caching the results. Caching will work, since the optimal sub-problem will always have the most optimal solution. In the earlier version, we cached against both the amount and the number of coins used. There we needed that since we were looking at all combinations. Now, we only calculate the minimum #coins, so we need to cache against only that. Here is the bottom-up approach. Here we start by finding the minimum #coins needed to change 1, 2, … so on until we hit V. At each step, we calculate the minimum for V by using Solution(V-coin[i]). This is very similar to how we arrive at the solution for Dijkstra’s single source shortest path. There, to get to a node M, we find the shortest path to some N and then add the edge from N to M. This is very similar. func coinChange(coins []int, amount int) int { if amount &lt;= 0 { return 0 } seen := make([]int, amount + 1) for i := 1; i &lt;= amount; i++ { min := 4111111111 for _, coin := range coins { res := -1 if i &gt;= coin { res = seen[i-coin] + 1 if res &lt; min { min = res } } } seen[i] = min } if seen[amount] == 4111111111 { return -1 } return seen[amount] } Knapsack problem Given weights W[0…n-1] and the value of the weights V[0…n-1], put the weights in a bag/knapsack of capacity W, so that the value is maximized. In this problem, we have one item of each weight and hence the subproblems will be when we either use an item or we don’t. If m[v,w] is the maximum value attained with items [1…v] for a capacity w, then m[0,w] = 0 //no value for empty Value array m[v,0] = 0 //no value for capacity=0 m[v,w] = max(m[v-1,w], m[v-1, w-W[v]] + V[v]) if w &gt; V[v] = m[v-1,w] if w &lt; V[v] The basic recurrence will keep evaluating the sub-problems and hence we will cache the results. The bottom-up approach immediately follows from this. func fillKnapsack(weights, values []int, capacity int) (maxValue int) { W := len(weights) V := len(Values) if W == 0 || V == 0 { return 0 } cache := make([][]int, V + 1) for i, _ := range cache { cache[i] = make([]int, capacity + 1) } for i := 0; i &lt;= V; i++ { for j := 0; j &lt;= capacity; j++ { if i == 0 || j == 0 { continue } if W[i-1] &lt;= capacity { cache[i][j] = cache[i-1][j] } else { x := cache[i-1][j] y := cache[i-1][j-W[i-1]] + V[i-1] if x &gt; y { cache[i][j] = x } else { cache[i][j] = y } } } } maxValue = cache[V][capacity] } Understanding this problem can help solve a great many problems. One of them is the N-sum problem where given an array of integers, we need to know if a subset of them can sum up to N. Edit Distance Given two character sequences, we need to find the edit-distance between them. Edit distance is used to measure the difference between the two sequences — ie., the number of operations required to transform one sequence into the other. Now the operations(addition of a character, deletion of a character or the replacement of a character) can be weighed. For the sake of simplicity, our example here doesn’t do that and assumes a cost of 1 for every operation. Levenshtein distance is a popular measure of edit distance and this is a simplified form of it. The general recursive implementation will use the following logic. If D(i,j) is used to indicate the edit distance between two sequences I[1…i] and J[1…j], then, //Edit distance for sequence and empty sequence is the length of the sequence itself. D(i,0) = i for 1 &lt;= i &lt;= len(I) D(0,j) = j for i &lt;= j &lt;= len(J) if I[i] == J[j], D(i,j) = D(i-1,j-1) else D(i,j) = min{D(i,j-1) + 1, //insertion D(i-1,j) + 1, //deletion D(i-1, j-1) + 1}//substitution Implementing this using recursion will mean re-computing the same subproblems repeatedly. The optimization would be the following. This can be optimized further by saving only two rows at any time, but that is not done here for simplicity. func min(A ...int) int { min := 4111111111 for _, a := range A { if min &gt; a { min = a } } return min } func minDistance(word1 string, word2 string) int { I := len(word1) J := len(word2) //Dij represents the edit distance between word1[0...i-1] and word2[0...j-1]. //Do D0j = j, Di0 = i, since the edit distance between word[0...n-1] and an empty string is n+1 D := make([][]int, I+1) for i, _ := range D { D[i] = make([]int, J+1) } for i := range D { D[i][0] = i } for j := range D[0] { D[0][j] = j } for i := 1; i &lt;= I; i++ { for j := 1; j &lt;= J; j++ { if word1[i-1] == word2[j-1] { D[i][j] = D[i-1][j-1] } else { D[i][j] = min(D[i][j-1] + 1, D[i-1][j] + 1, 1 + D[i-1][j-1]) } } } return D[I][J] }" />
<meta property="og:description" content="Overview Not many who have left school use concepts such as Dynamic Programming on a day to day basis. Most only to come to them when preparing for an interview. However, this is a useful algorithmic technique and it helps to understand it. This post should provide an introduction to Dynamic Programming and after reading this, it should be possible to attempt the problems provided at the end with ease. Dynamic programming (or dynamic optimization) is a method for solving problems which can split into multiple simpler, smaller and overlapping (or repeating) sub-problems. Since the sub-problems are overlapping (meaning same sub-problems get repeated several times), it will be possible to save the solutions to them in a memory-based data structure. This helps reduce computation time at the expense of (hopefully moderate) storage space. Each of the sub-problem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. The technique of storing solutions to sub-problems instead of recomputing them is called Memoization. The two main requirements for a problem to be solved this way are Optimal Substructure and Overlapping sub-problems. Optimal Substructure This simply means that the optimal solution to the actual problem is a combination of the optimal solutions to its sub-problems. This will become clearer as we look at Examples, but a quick look at Dijkstra’s algorithm for single-source shortest path computation will help us understand this. In that, we repeatedly compute the shortest so-far from a source, by storing the vertices in a priority queue, weighted by their distance from the source. So the shortest distance from a node s to a node n will be d(s,n) = d(s,m) + e(m,n) where e(m,n) is the length of the edge from m to n. In this case, the optimal substructure is that the shortest distance from s to n is the shortest distance from s to m + the edge from m to n. Recursion plays a big role in visualizing these problems and is usually the first approach to solving such problems. Overlapping Sub-Problems This requirement needs the problem to be split into a small space of sub-problems which would be solved over and over again in the process of getting to the solution of the problem — ie., we should be solving the same problems over and over again instead of solving newer and newer sub-problems. An example of non-overlapping subproblems is the merge-sort (and quicksort). Merge sort falls into the Divide and Conquer category, since we solve distinct subproblems and repeatedly merge the results. Example: To calculate Fibonacci numbers, fib(4) = fib(3) + fib(2) and fib(3) = fib(2) + fib(1) and so on. For each higher number in the series, if we solve this recursively, we will end up calculating the same lower-order problems over and over again. Such is a requirement for the problem to fall into this category. Memoization If the above two requirements are met, then we can save or cache the results to be looked up later when we are solving the same sub-problems again and again. This will result in a huge drop in computation times at the expence of a small increase in memory space consumption. For example, in the fibonacci series problem, when calculating fib(4), we need fib(3) and fib(2). But, fib(3) = fib(2) + fib(1). So fib(2) could be calculated twice here. If we cache fib(2) the first time it is calculated and then re-use it, this optimizes the computation. This is memoization. Solving the Problem There are two approaches to solving such problems — the top-down approach and the bottom-up approach. Top-down approach This directly results from the recursion &amp; memoization principles. We start from the problem and recursively solve the sub-problems while caching the results. Example: for fibonacci series, to get fib(50) - the 50th number in the series, we will calculate fib(49) and fib(48) and for fib(49), we’ll calculate fib(48) and fib(47) and so on recursively. If we think about this, then we can see that the first actual computation per se will be to compute the edge cases fib(0) and fib(1) and then fib(2) and so on until we get to fib(49) and fib(48). We recursively compute the smaller problems optimally and cache the results. This directly leads to the next approach. Bottom-up approach In this approach, we start from a base case and iteratively build up to the solution we are looking for. Instead of recursively solving the problem, we formulate the sub problems, and solve them first before using them to build a solution for the problem itself. It’s usually a table that stores the data needed with the indices somehow referring to the parameters of the problem itself. Taking the same example of Fibonacci numbers, if we need fib(50), we start at fib(0) and fib(1) as our base cases, and iteratively build the solutions to bigger problems from them to get to fib(50). Examples The key to solving these problems is identifying the recurrence correctly and what the table actually represents. Once that is done, formulating the table is trivial. Fibonacci numbers A good example is calculating Fibonacci numbers. fib(n) = fib(n-1) + fib(n-2). A recursive approach to solving this would be: func fibonacci(num int) int { if num == 0 || num == 1 { return 1 } return fibonacci(num - 1) + fibonacci(num - 2) } We can see the calls to sub-problems will quickly explode computing the same problems over and over again, especially the smaller sub-problems — fib(2), fib(1), fib(0). To avoid this, we could cache the solution. func fibonacci(num int, cache map[int]int) int { if num == 0 || num == 1 { // base case return num } result := 0 if result, ok := cache[num]; ok { return result } result = fibonacci(num - 1, cache) + fibonacci(num - 2, cache) cache[num] = result return result } We now store the solution and then use it if needed without having to recompute the sub-problems again. This leads to out next optimization where we start from the bottom-up. func fibonacci(num int) int { // base cases num1 := 0 num2 := 1 fib := 0 for i := 2; i &lt;= num; i++ { fib = num1 + num2 num1 = num2 num2 = fib } return fib } Coin change problems There are two coin change problems. The two seem similar, but are subtly different. Given an amount and a list of coin values (each with infinite coins), find out in how many ways we can make change for the amount. When we have n coins, we need to count the number of ways we can make change with all combination of coins. Say we have [1,2,5], we need to find out in how many ways we make change with [1], [2], [5] [1,2], [1,5], [2,5], [1,2,5]. But counting this way is not efficient. So we look at this problem another way. Each time we either use a coin or we don’t and then we count the number of ways and then we sum them up. ie., fn(Amount, coins[1...n]) = fn(Amount - coin[n], coins[1...n]] + fn(Amount, coins[1...n-1]) This way, we get all combination of coins. Not intuitive right away, but makes sense if we think about it. This leads to the following solution. func change(amount int, coins []int) int { if amount &lt; 0 { return 0 } if amount == 0 { return 1 } if len(coins) == 0 { return 0 } length := len(coins) return change(amount, coins[:length-1]) + change(amount - coins[length-1], coins) } The top-down approach will be trivial. We simply need to cache the solution for [amount][len(coins))]. The bottom up approach is more interesting. func change(amount int, coins []int) int { cache := make([][]int, amount+1) for i := 0; i &lt;= amount; i++ { cache[i] = make([]int, len(coins) + 1) } for i := 0; i &lt;= len(coins); i++ { cache[0][i] = 1 } for i := 1; i &lt;= len(coins); i++ { for j := 1; j &lt;= amount; j++ { if j - coins[i-1] &gt;= 0 { //cached optimal sub-problem solution cache[j][i] = cache[j - coins[i-1]][i] } cache[j][i] = cache[j][i] + cache[j][i-1] } } return cache[amount][len(coins)] } Given an amount and a list of coin values (each with infinite coins), find out the minimum number of coins with which we can make change for the amount. This problem can’t be solved by looking at it like we did for the previous problem. We don’t need all combinations of change-making. We only need one — the minimum #coins that can make the change. The subproblem here is that at each point, we use the best coin and then try and find the minimum number of coins required to change the remaining amount with ALL coins. This means we can’t take the approach as in the previous variety, where we can use any coin. If V is the amount to be changed, and there are n coins, the recursion here can be represented by If V == 0, 0 coins are needed. If V &gt; 0 { minCoins(coins[0...n-1], V) = min {1 + minCoins(coins[0...n-1], V - coins[i])} where V &gt; coins[i] &amp;&amp; i varies from 0...m-1. } The simple recursion approach will work by just calling the above. The top-down approach will work by caching the results. Caching will work, since the optimal sub-problem will always have the most optimal solution. In the earlier version, we cached against both the amount and the number of coins used. There we needed that since we were looking at all combinations. Now, we only calculate the minimum #coins, so we need to cache against only that. Here is the bottom-up approach. Here we start by finding the minimum #coins needed to change 1, 2, … so on until we hit V. At each step, we calculate the minimum for V by using Solution(V-coin[i]). This is very similar to how we arrive at the solution for Dijkstra’s single source shortest path. There, to get to a node M, we find the shortest path to some N and then add the edge from N to M. This is very similar. func coinChange(coins []int, amount int) int { if amount &lt;= 0 { return 0 } seen := make([]int, amount + 1) for i := 1; i &lt;= amount; i++ { min := 4111111111 for _, coin := range coins { res := -1 if i &gt;= coin { res = seen[i-coin] + 1 if res &lt; min { min = res } } } seen[i] = min } if seen[amount] == 4111111111 { return -1 } return seen[amount] } Knapsack problem Given weights W[0…n-1] and the value of the weights V[0…n-1], put the weights in a bag/knapsack of capacity W, so that the value is maximized. In this problem, we have one item of each weight and hence the subproblems will be when we either use an item or we don’t. If m[v,w] is the maximum value attained with items [1…v] for a capacity w, then m[0,w] = 0 //no value for empty Value array m[v,0] = 0 //no value for capacity=0 m[v,w] = max(m[v-1,w], m[v-1, w-W[v]] + V[v]) if w &gt; V[v] = m[v-1,w] if w &lt; V[v] The basic recurrence will keep evaluating the sub-problems and hence we will cache the results. The bottom-up approach immediately follows from this. func fillKnapsack(weights, values []int, capacity int) (maxValue int) { W := len(weights) V := len(Values) if W == 0 || V == 0 { return 0 } cache := make([][]int, V + 1) for i, _ := range cache { cache[i] = make([]int, capacity + 1) } for i := 0; i &lt;= V; i++ { for j := 0; j &lt;= capacity; j++ { if i == 0 || j == 0 { continue } if W[i-1] &lt;= capacity { cache[i][j] = cache[i-1][j] } else { x := cache[i-1][j] y := cache[i-1][j-W[i-1]] + V[i-1] if x &gt; y { cache[i][j] = x } else { cache[i][j] = y } } } } maxValue = cache[V][capacity] } Understanding this problem can help solve a great many problems. One of them is the N-sum problem where given an array of integers, we need to know if a subset of them can sum up to N. Edit Distance Given two character sequences, we need to find the edit-distance between them. Edit distance is used to measure the difference between the two sequences — ie., the number of operations required to transform one sequence into the other. Now the operations(addition of a character, deletion of a character or the replacement of a character) can be weighed. For the sake of simplicity, our example here doesn’t do that and assumes a cost of 1 for every operation. Levenshtein distance is a popular measure of edit distance and this is a simplified form of it. The general recursive implementation will use the following logic. If D(i,j) is used to indicate the edit distance between two sequences I[1…i] and J[1…j], then, //Edit distance for sequence and empty sequence is the length of the sequence itself. D(i,0) = i for 1 &lt;= i &lt;= len(I) D(0,j) = j for i &lt;= j &lt;= len(J) if I[i] == J[j], D(i,j) = D(i-1,j-1) else D(i,j) = min{D(i,j-1) + 1, //insertion D(i-1,j) + 1, //deletion D(i-1, j-1) + 1}//substitution Implementing this using recursion will mean re-computing the same subproblems repeatedly. The optimization would be the following. This can be optimized further by saving only two rows at any time, but that is not done here for simplicity. func min(A ...int) int { min := 4111111111 for _, a := range A { if min &gt; a { min = a } } return min } func minDistance(word1 string, word2 string) int { I := len(word1) J := len(word2) //Dij represents the edit distance between word1[0...i-1] and word2[0...j-1]. //Do D0j = j, Di0 = i, since the edit distance between word[0...n-1] and an empty string is n+1 D := make([][]int, I+1) for i, _ := range D { D[i] = make([]int, J+1) } for i := range D { D[i][0] = i } for j := range D[0] { D[0][j] = j } for i := 1; i &lt;= I; i++ { for j := 1; j &lt;= J; j++ { if word1[i-1] == word2[j-1] { D[i][j] = D[i-1][j-1] } else { D[i][j] = min(D[i][j-1] + 1, D[i-1][j] + 1, 1 + D[i-1][j-1]) } } } return D[I][J] }" />
<link rel="canonical" href="http://localhost:4002/blog/2017/04/17/intro-to-dynamic-programming.html" />
<meta property="og:url" content="http://localhost:4002/blog/2017/04/17/intro-to-dynamic-programming.html" />
<meta property="og:site_name" content="Vishnu Raghavan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-17T11:29:57-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Introduction to Dynamic Programming!" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4002/blog/2017/04/17/intro-to-dynamic-programming.html"},"url":"http://localhost:4002/blog/2017/04/17/intro-to-dynamic-programming.html","headline":"Introduction to Dynamic Programming!","dateModified":"2017-04-17T11:29:57-07:00","datePublished":"2017-04-17T11:29:57-07:00","description":"Overview Not many who have left school use concepts such as Dynamic Programming on a day to day basis. Most only to come to them when preparing for an interview. However, this is a useful algorithmic technique and it helps to understand it. This post should provide an introduction to Dynamic Programming and after reading this, it should be possible to attempt the problems provided at the end with ease. Dynamic programming (or dynamic optimization) is a method for solving problems which can split into multiple simpler, smaller and overlapping (or repeating) sub-problems. Since the sub-problems are overlapping (meaning same sub-problems get repeated several times), it will be possible to save the solutions to them in a memory-based data structure. This helps reduce computation time at the expense of (hopefully moderate) storage space. Each of the sub-problem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. The technique of storing solutions to sub-problems instead of recomputing them is called Memoization. The two main requirements for a problem to be solved this way are Optimal Substructure and Overlapping sub-problems. Optimal Substructure This simply means that the optimal solution to the actual problem is a combination of the optimal solutions to its sub-problems. This will become clearer as we look at Examples, but a quick look at Dijkstra’s algorithm for single-source shortest path computation will help us understand this. In that, we repeatedly compute the shortest so-far from a source, by storing the vertices in a priority queue, weighted by their distance from the source. So the shortest distance from a node s to a node n will be d(s,n) = d(s,m) + e(m,n) where e(m,n) is the length of the edge from m to n. In this case, the optimal substructure is that the shortest distance from s to n is the shortest distance from s to m + the edge from m to n. Recursion plays a big role in visualizing these problems and is usually the first approach to solving such problems. Overlapping Sub-Problems This requirement needs the problem to be split into a small space of sub-problems which would be solved over and over again in the process of getting to the solution of the problem — ie., we should be solving the same problems over and over again instead of solving newer and newer sub-problems. An example of non-overlapping subproblems is the merge-sort (and quicksort). Merge sort falls into the Divide and Conquer category, since we solve distinct subproblems and repeatedly merge the results. Example: To calculate Fibonacci numbers, fib(4) = fib(3) + fib(2) and fib(3) = fib(2) + fib(1) and so on. For each higher number in the series, if we solve this recursively, we will end up calculating the same lower-order problems over and over again. Such is a requirement for the problem to fall into this category. Memoization If the above two requirements are met, then we can save or cache the results to be looked up later when we are solving the same sub-problems again and again. This will result in a huge drop in computation times at the expence of a small increase in memory space consumption. For example, in the fibonacci series problem, when calculating fib(4), we need fib(3) and fib(2). But, fib(3) = fib(2) + fib(1). So fib(2) could be calculated twice here. If we cache fib(2) the first time it is calculated and then re-use it, this optimizes the computation. This is memoization. Solving the Problem There are two approaches to solving such problems — the top-down approach and the bottom-up approach. Top-down approach This directly results from the recursion &amp; memoization principles. We start from the problem and recursively solve the sub-problems while caching the results. Example: for fibonacci series, to get fib(50) - the 50th number in the series, we will calculate fib(49) and fib(48) and for fib(49), we’ll calculate fib(48) and fib(47) and so on recursively. If we think about this, then we can see that the first actual computation per se will be to compute the edge cases fib(0) and fib(1) and then fib(2) and so on until we get to fib(49) and fib(48). We recursively compute the smaller problems optimally and cache the results. This directly leads to the next approach. Bottom-up approach In this approach, we start from a base case and iteratively build up to the solution we are looking for. Instead of recursively solving the problem, we formulate the sub problems, and solve them first before using them to build a solution for the problem itself. It’s usually a table that stores the data needed with the indices somehow referring to the parameters of the problem itself. Taking the same example of Fibonacci numbers, if we need fib(50), we start at fib(0) and fib(1) as our base cases, and iteratively build the solutions to bigger problems from them to get to fib(50). Examples The key to solving these problems is identifying the recurrence correctly and what the table actually represents. Once that is done, formulating the table is trivial. Fibonacci numbers A good example is calculating Fibonacci numbers. fib(n) = fib(n-1) + fib(n-2). A recursive approach to solving this would be: func fibonacci(num int) int { if num == 0 || num == 1 { return 1 } return fibonacci(num - 1) + fibonacci(num - 2) } We can see the calls to sub-problems will quickly explode computing the same problems over and over again, especially the smaller sub-problems — fib(2), fib(1), fib(0). To avoid this, we could cache the solution. func fibonacci(num int, cache map[int]int) int { if num == 0 || num == 1 { // base case return num } result := 0 if result, ok := cache[num]; ok { return result } result = fibonacci(num - 1, cache) + fibonacci(num - 2, cache) cache[num] = result return result } We now store the solution and then use it if needed without having to recompute the sub-problems again. This leads to out next optimization where we start from the bottom-up. func fibonacci(num int) int { // base cases num1 := 0 num2 := 1 fib := 0 for i := 2; i &lt;= num; i++ { fib = num1 + num2 num1 = num2 num2 = fib } return fib } Coin change problems There are two coin change problems. The two seem similar, but are subtly different. Given an amount and a list of coin values (each with infinite coins), find out in how many ways we can make change for the amount. When we have n coins, we need to count the number of ways we can make change with all combination of coins. Say we have [1,2,5], we need to find out in how many ways we make change with [1], [2], [5] [1,2], [1,5], [2,5], [1,2,5]. But counting this way is not efficient. So we look at this problem another way. Each time we either use a coin or we don’t and then we count the number of ways and then we sum them up. ie., fn(Amount, coins[1...n]) = fn(Amount - coin[n], coins[1...n]] + fn(Amount, coins[1...n-1]) This way, we get all combination of coins. Not intuitive right away, but makes sense if we think about it. This leads to the following solution. func change(amount int, coins []int) int { if amount &lt; 0 { return 0 } if amount == 0 { return 1 } if len(coins) == 0 { return 0 } length := len(coins) return change(amount, coins[:length-1]) + change(amount - coins[length-1], coins) } The top-down approach will be trivial. We simply need to cache the solution for [amount][len(coins))]. The bottom up approach is more interesting. func change(amount int, coins []int) int { cache := make([][]int, amount+1) for i := 0; i &lt;= amount; i++ { cache[i] = make([]int, len(coins) + 1) } for i := 0; i &lt;= len(coins); i++ { cache[0][i] = 1 } for i := 1; i &lt;= len(coins); i++ { for j := 1; j &lt;= amount; j++ { if j - coins[i-1] &gt;= 0 { //cached optimal sub-problem solution cache[j][i] = cache[j - coins[i-1]][i] } cache[j][i] = cache[j][i] + cache[j][i-1] } } return cache[amount][len(coins)] } Given an amount and a list of coin values (each with infinite coins), find out the minimum number of coins with which we can make change for the amount. This problem can’t be solved by looking at it like we did for the previous problem. We don’t need all combinations of change-making. We only need one — the minimum #coins that can make the change. The subproblem here is that at each point, we use the best coin and then try and find the minimum number of coins required to change the remaining amount with ALL coins. This means we can’t take the approach as in the previous variety, where we can use any coin. If V is the amount to be changed, and there are n coins, the recursion here can be represented by If V == 0, 0 coins are needed. If V &gt; 0 { minCoins(coins[0...n-1], V) = min {1 + minCoins(coins[0...n-1], V - coins[i])} where V &gt; coins[i] &amp;&amp; i varies from 0...m-1. } The simple recursion approach will work by just calling the above. The top-down approach will work by caching the results. Caching will work, since the optimal sub-problem will always have the most optimal solution. In the earlier version, we cached against both the amount and the number of coins used. There we needed that since we were looking at all combinations. Now, we only calculate the minimum #coins, so we need to cache against only that. Here is the bottom-up approach. Here we start by finding the minimum #coins needed to change 1, 2, … so on until we hit V. At each step, we calculate the minimum for V by using Solution(V-coin[i]). This is very similar to how we arrive at the solution for Dijkstra’s single source shortest path. There, to get to a node M, we find the shortest path to some N and then add the edge from N to M. This is very similar. func coinChange(coins []int, amount int) int { if amount &lt;= 0 { return 0 } seen := make([]int, amount + 1) for i := 1; i &lt;= amount; i++ { min := 4111111111 for _, coin := range coins { res := -1 if i &gt;= coin { res = seen[i-coin] + 1 if res &lt; min { min = res } } } seen[i] = min } if seen[amount] == 4111111111 { return -1 } return seen[amount] } Knapsack problem Given weights W[0…n-1] and the value of the weights V[0…n-1], put the weights in a bag/knapsack of capacity W, so that the value is maximized. In this problem, we have one item of each weight and hence the subproblems will be when we either use an item or we don’t. If m[v,w] is the maximum value attained with items [1…v] for a capacity w, then m[0,w] = 0 //no value for empty Value array m[v,0] = 0 //no value for capacity=0 m[v,w] = max(m[v-1,w], m[v-1, w-W[v]] + V[v]) if w &gt; V[v] = m[v-1,w] if w &lt; V[v] The basic recurrence will keep evaluating the sub-problems and hence we will cache the results. The bottom-up approach immediately follows from this. func fillKnapsack(weights, values []int, capacity int) (maxValue int) { W := len(weights) V := len(Values) if W == 0 || V == 0 { return 0 } cache := make([][]int, V + 1) for i, _ := range cache { cache[i] = make([]int, capacity + 1) } for i := 0; i &lt;= V; i++ { for j := 0; j &lt;= capacity; j++ { if i == 0 || j == 0 { continue } if W[i-1] &lt;= capacity { cache[i][j] = cache[i-1][j] } else { x := cache[i-1][j] y := cache[i-1][j-W[i-1]] + V[i-1] if x &gt; y { cache[i][j] = x } else { cache[i][j] = y } } } } maxValue = cache[V][capacity] } Understanding this problem can help solve a great many problems. One of them is the N-sum problem where given an array of integers, we need to know if a subset of them can sum up to N. Edit Distance Given two character sequences, we need to find the edit-distance between them. Edit distance is used to measure the difference between the two sequences — ie., the number of operations required to transform one sequence into the other. Now the operations(addition of a character, deletion of a character or the replacement of a character) can be weighed. For the sake of simplicity, our example here doesn’t do that and assumes a cost of 1 for every operation. Levenshtein distance is a popular measure of edit distance and this is a simplified form of it. The general recursive implementation will use the following logic. If D(i,j) is used to indicate the edit distance between two sequences I[1…i] and J[1…j], then, //Edit distance for sequence and empty sequence is the length of the sequence itself. D(i,0) = i for 1 &lt;= i &lt;= len(I) D(0,j) = j for i &lt;= j &lt;= len(J) if I[i] == J[j], D(i,j) = D(i-1,j-1) else D(i,j) = min{D(i,j-1) + 1, //insertion D(i-1,j) + 1, //deletion D(i-1, j-1) + 1}//substitution Implementing this using recursion will mean re-computing the same subproblems repeatedly. The optimization would be the following. This can be optimized further by saving only two rows at any time, but that is not done here for simplicity. func min(A ...int) int { min := 4111111111 for _, a := range A { if min &gt; a { min = a } } return min } func minDistance(word1 string, word2 string) int { I := len(word1) J := len(word2) //Dij represents the edit distance between word1[0...i-1] and word2[0...j-1]. //Do D0j = j, Di0 = i, since the edit distance between word[0...n-1] and an empty string is n+1 D := make([][]int, I+1) for i, _ := range D { D[i] = make([]int, J+1) } for i := range D { D[i][0] = i } for j := range D[0] { D[0][j] = j } for i := 1; i &lt;= I; i++ { for j := 1; j &lt;= J; j++ { if word1[i-1] == word2[j-1] { D[i][j] = D[i-1][j-1] } else { D[i][j] = min(D[i][j-1] + 1, D[i-1][j] + 1, 1 + D[i-1][j-1]) } } } return D[I][J] }","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4002/feed.xml" title="Vishnu Raghavan" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Vishnu Raghavan</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Introduction to Dynamic Programming!</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-04-17T11:29:57-07:00" itemprop="datePublished">Apr 17, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="overview">Overview</h1>

<p>Not many who have left school use concepts such as Dynamic Programming on a day to day basis. Most only to come to them when preparing for an interview. However, this is a useful algorithmic technique and it helps to understand it. This post should provide an introduction to Dynamic Programming and after reading this, it should be possible to attempt the problems provided at the end with ease.</p>

<p>Dynamic programming (or dynamic optimization) is a method for solving problems which can split into multiple simpler, smaller and overlapping (or repeating) sub-problems. Since the sub-problems are overlapping (meaning same sub-problems get repeated several times), it will be possible to save the solutions to them in a memory-based data structure. This helps reduce computation time at the expense of (hopefully moderate) storage space. Each of the sub-problem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. The technique of storing solutions to sub-problems instead of recomputing them is called Memoization.</p>

<p>The two main requirements for a problem to be solved this way are Optimal Substructure and Overlapping sub-problems.</p>

<h1 id="optimal-substructure">Optimal Substructure</h1>

<p>This simply means that the optimal solution to the actual problem is a combination of the optimal solutions to its sub-problems. This will become clearer as we look at Examples, but a quick look at Dijkstra’s algorithm for single-source shortest path computation will help us understand this. In that, we repeatedly compute the shortest so-far from a source, by storing the vertices in a priority queue, weighted by their distance from the source. So the shortest distance from a node s to a node n will be</p>

<p><code class="language-plaintext highlighter-rouge">d(s,n) = d(s,m) + e(m,n)</code></p>

<p>where e(m,n) is the length of the edge from m to n. In this case, the optimal substructure is that the shortest distance from s to n is the shortest distance from s to m + the edge from m to n. Recursion plays a big role in visualizing these problems and is usually the first approach to solving such problems.</p>

<h1 id="overlapping-sub-problems">Overlapping Sub-Problems</h1>

<p>This requirement needs the problem to be split into a small space of sub-problems which would be solved over and over again in the process of getting to the solution of the problem — ie., we should be solving the same problems over and over again instead of solving newer and newer sub-problems. An example of non-overlapping subproblems is the merge-sort (and quicksort). Merge sort falls into the Divide and Conquer category, since we solve distinct subproblems and repeatedly merge the results.</p>

<p>Example: To calculate Fibonacci numbers, <code class="language-plaintext highlighter-rouge">fib(4) = fib(3) + fib(2)</code> and <code class="language-plaintext highlighter-rouge">fib(3) = fib(2) + fib(1)</code> and so on. For each higher number in the series, if we solve this recursively, we will end up calculating the same lower-order problems over and over again. Such is a requirement for the problem to fall into this category.</p>

<h1 id="memoization">Memoization</h1>

<p>If the above two requirements are met, then we can save or cache the results to be looked up later when we are solving the same sub-problems again and again. This will result in a huge drop in computation times at the expence of a small increase in memory space consumption. For example, in the fibonacci series problem, when calculating fib(4), we need fib(3) and fib(2). But, fib(3) = fib(2) + fib(1). So fib(2) could be calculated twice here. If we cache fib(2) the first time it is calculated and then re-use it, this optimizes the computation. This is memoization.</p>

<h1 id="solving-theproblem">Solving the Problem</h1>

<p>There are two approaches to solving such problems — the top-down approach and the bottom-up approach.</p>

<h2 id="top-down-approach">Top-down approach</h2>

<p>This directly results from the recursion &amp; memoization principles. We start from the problem and recursively solve the sub-problems while caching the results. Example: for fibonacci series, to get fib(50) - the 50th number in the series, we will calculate fib(49) and fib(48) and for fib(49), we’ll calculate fib(48) and fib(47) and so on recursively. If we think about this, then we can see that the first actual computation per se will be to compute the edge cases fib(0) and fib(1) and then fib(2) and so on until we get to fib(49) and fib(48). We recursively compute the smaller problems optimally and cache the results. This directly leads to the next approach.</p>

<h2 id="bottom-up-approach">Bottom-up approach</h2>

<p>In this approach, we start from a base case and iteratively build up to the solution we are looking for. Instead of recursively solving the problem, we formulate the sub problems, and solve them first before using them to build a solution for the problem itself. It’s usually a table that stores the data needed with the indices somehow referring to the parameters of the problem itself. Taking the same example of Fibonacci numbers, if we need fib(50), we start at fib(0) and fib(1) as our base cases, and iteratively build the solutions to bigger problems from them to get to fib(50).</p>

<h1 id="examples">Examples</h1>

<p>The key to solving these problems is identifying the recurrence correctly and what the table actually represents. Once that is done, formulating the table is trivial.</p>

<h2 id="fibonacci-numbers">Fibonacci numbers</h2>

<p>A good example is calculating Fibonacci numbers. <code class="language-plaintext highlighter-rouge">fib(n) = fib(n-1) + fib(n-2)</code>. A recursive approach to solving this would be:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>We can see the calls to sub-problems will quickly explode computing the same problems over and over again, especially the smaller sub-problems — fib(2), fib(1), fib(0).</p>

<p>To avoid this, we could cache the solution.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="n">int</span><span class="p">,</span> <span class="n">cache</span> <span class="n">map</span><span class="p">[</span><span class="n">int</span><span class="p">]</span><span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="sr">//</span> <span class="n">base</span> <span class="k">case</span>
        <span class="k">return</span> <span class="n">num</span>
   <span class="p">}</span>
   <span class="n">result</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span>
   <span class="k">if</span> <span class="n">result</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">num</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span>
   <span class="p">}</span>
   <span class="n">result</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
    
   <span class="n">cache</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
   <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span></code></pre></figure>

<p>We now store the solution and then use it if needed without having to recompute the sub-problems again. This leads to out next optimization where we start from the bottom-up.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="sr">//</span> <span class="n">base</span> <span class="n">cases</span>
    <span class="n">num1</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span>
    <span class="n">num2</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span>
    <span class="n">fib</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fib</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="n">num2</span>
        <span class="n">num2</span> <span class="o">=</span> <span class="n">fib</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fib</span>
<span class="p">}</span></code></pre></figure>

<h2 id="coin-changeproblems">Coin change problems</h2>

<p>There are two coin change problems. The two seem similar, but are subtly different.</p>

<h3 id="given-an-amount-and-a-list-of-coin-values-each-with-infinite-coins-find-out-in-how-many-ways-we-can-make-change-for-theamount">Given an amount and a list of coin values (each with infinite coins), find out in how many ways we can make change for the amount.</h3>

<p>When we have n coins, we need to count the number of ways we can make change with all combination of coins. Say we have [1,2,5], we need to find out in how many ways we make change with [1], [2], [5] [1,2], [1,5], [2,5], [1,2,5]. But counting this way is not efficient. So we look at this problem another way. Each time we either use a coin or we don’t and then we count the number of ways and then we sum them up. ie.,</p>

<p><code class="language-plaintext highlighter-rouge">fn(Amount, coins[1...n]) = fn(Amount - coin[n], coins[1...n]] + fn(Amount, coins[1...n-1])</code></p>

<p>This way, we get all combination of coins. Not intuitive right away, but makes sense if we think about it. This leads to the following solution.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">change</span><span class="p">(</span><span class="n">amount</span> <span class="n">int</span><span class="p">,</span> <span class="n">coins</span> <span class="p">[]</span><span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="n">length</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">change</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">coins</span><span class="p">[</span><span class="ss">:length</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">change</span><span class="p">(</span><span class="n">amount</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">coins</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The top-down approach will be trivial. We simply need to cache the solution for [amount][len(coins))]. The bottom up approach is more interesting.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">change</span><span class="p">(</span><span class="n">amount</span> <span class="n">int</span><span class="p">,</span> <span class="n">coins</span> <span class="p">[]</span><span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="n">cache</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][]</span><span class="n">int</span><span class="p">,</span> <span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">int</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>             
	    <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="sr">//</span><span class="n">cached</span> <span class="n">optimal</span> <span class="nb">sub</span><span class="o">-</span><span class="n">problem</span> <span class="n">solution</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">amount</span><span class="p">][</span><span class="n">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)]</span>
<span class="p">}</span></code></pre></figure>

<h3 id="given-an-amount-and-a-list-of-coin-values-each-with-infinite-coins-find-out-the-minimum-number-of-coins-with-which-we-can-make-change-for-theamount">Given an amount and a list of coin values (each with infinite coins), find out the minimum number of coins with which we can make change for the amount.</h3>

<p>This problem can’t be solved by looking at it like we did for the previous problem. We don’t need all combinations of change-making. We only need one — the minimum #coins that can make the change. The subproblem here is that at each point, we use the best coin and then try and find the minimum number of coins required to change the remaining amount with ALL coins. This means we can’t take the approach as in the previous variety, where we can use any coin.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">If</span> <span class="no">V</span> <span class="n">is</span> <span class="n">the</span> <span class="n">amount</span> <span class="n">to</span> <span class="n">be</span> <span class="n">changed</span><span class="p">,</span> <span class="n">and</span> <span class="n">there</span> <span class="n">are</span> <span class="n">n</span> <span class="n">coins</span><span class="p">,</span> <span class="n">the</span> <span class="n">recursion</span> <span class="n">here</span> <span class="n">can</span> <span class="n">be</span> <span class="n">represented</span> <span class="n">by</span>

<span class="no">If</span> <span class="no">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="n">coins</span> <span class="n">are</span> <span class="n">needed</span><span class="o">.</span>
<span class="no">If</span> <span class="no">V</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">minCoins</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="no">V</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span> <span class="p">{</span><span class="mi">1</span> <span class="o">+</span> <span class="n">minCoins</span><span class="p">(</span><span class="n">coins</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="no">V</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">])}</span>
                                <span class="n">where</span> <span class="no">V</span> <span class="o">&gt;</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="n">varies</span> <span class="n">from</span> <span class="mi">0</span><span class="o">...</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span>
<span class="p">}</span></code></pre></figure>

<p>The simple recursion approach will work by just calling the above. The top-down approach will work by caching the results. Caching will work, since the optimal sub-problem will always have the most optimal solution. In the earlier version, we cached against both the amount and the number of coins used. There we needed that since we were looking at all combinations. Now, we only calculate the minimum #coins, so we need to cache against only that.</p>

<p>Here is the bottom-up approach. Here we start by finding the minimum #coins needed to change 1, 2, … so on until we hit V. At each step, we calculate the minimum for V by using Solution(V-coin[i]). This is very similar to how we arrive at the solution for Dijkstra’s single source shortest path. There, to get to a node M, we find the shortest path to some N and then add the edge from N to M. This is very similar.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">coinChange</span><span class="p">(</span><span class="n">coins</span> <span class="p">[]</span><span class="n">int</span><span class="p">,</span> <span class="n">amount</span> <span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="n">seen</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">int</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="n">min</span> <span class="p">:</span><span class="o">=</span> <span class="mi">4111111111</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">coin</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="n">coins</span> <span class="p">{</span>
	    <span class="n">res</span> <span class="p">:</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span>             
	    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">coin</span>  <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="p">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">res</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>   
        <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4111111111</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">seen</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure>

<h2 id="knapsack-problem">Knapsack problem</h2>

<p>Given weights W[0…n-1] and the value of the weights V[0…n-1], put the weights in a bag/knapsack of capacity W, so that the value is maximized.</p>

<p>In this problem, we have one item of each weight and hence the subproblems will be when we either use an item or we don’t. If m[v,w] is the maximum value attained with items [1…v] for a capacity w, then</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">/</span><span class="sr">/no value for empty Value array
m[v,0] = 0 /</span><span class="o">/</span><span class="n">no</span> <span class="n">value</span> <span class="k">for</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">0</span>
<span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="no">W</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">+</span> <span class="no">V</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="no">V</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
       <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="p">]</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="no">V</span><span class="p">[</span><span class="n">v</span><span class="p">]</span></code></pre></figure>

<p>The basic recurrence will keep evaluating the sub-problems and hence we will cache the results. The bottom-up approach immediately follows from this.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">fillKnapsack</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">values</span> <span class="p">[]</span><span class="n">int</span><span class="p">,</span> <span class="n">capacity</span> <span class="n">int</span><span class="p">)</span> <span class="p">(</span><span class="n">maxValue</span> <span class="n">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="no">W</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="no">V</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="no">Values</span><span class="p">)</span>
    <span class="k">if</span> <span class="no">W</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="no">V</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="n">cache</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][]</span><span class="n">int</span><span class="p">,</span> <span class="no">V</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="n">cache</span> <span class="p">{</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">int</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">continue</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="no">W</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">capacity</span> <span class="p">{</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">y</span> <span class="p">:</span><span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="no">W</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="no">V</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">{</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">maxValue</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="no">V</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure>

<p>Understanding this problem can help solve a great many problems. One of them is the N-sum problem where given an array of integers, we need to know if a subset of them can sum up to N.</p>

<h2 id="edit-distance">Edit Distance</h2>

<p>Given two character sequences, we need to find the edit-distance between them. Edit distance is used to measure the difference between the two sequences — ie., the number of operations required to transform one sequence into the other.</p>

<p>Now the operations(addition of a character, deletion of a character or the replacement of a character) can be weighed. For the sake of simplicity, our example here doesn’t do that and assumes a cost of 1 for every operation.</p>

<p>Levenshtein distance is a popular measure of edit distance and this is a simplified form of it. The general recursive implementation will use the following logic. If D(i,j) is used to indicate the edit distance between two sequences I[1…i] and J[1…j], then,</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sr">//</span><span class="no">Edit</span> <span class="n">distance</span> <span class="k">for</span> <span class="n">sequence</span> <span class="n">and</span> <span class="n">empty</span> <span class="n">sequence</span> <span class="n">is</span> <span class="n">the</span> <span class="n">length</span> <span class="n">of</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">itself</span><span class="o">.</span>
<span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>  <span class="k">for</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">(</span><span class="no">I</span><span class="p">)</span>
<span class="no">D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">j</span>  <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">(</span><span class="no">J</span><span class="p">)</span>
<span class="k">if</span> <span class="no">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="no">J</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span> <span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="p">{</span><span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>   <span class="sr">//inse</span><span class="n">rtion</span>
                  <span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>   <span class="sr">//</span><span class="n">deletion</span>
                  <span class="no">D</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="o">/</span><span class="sr">/substitution</span></code></pre></figure>

<p>Implementing this using recursion will mean re-computing the same subproblems repeatedly. The optimization would be the following. This can be optimized further by saving only two rows at any time, but that is not done here for simplicity.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">func</span> <span class="n">min</span><span class="p">(</span><span class="no">A</span> <span class="o">...</span><span class="n">int</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="n">min</span> <span class="p">:</span><span class="o">=</span> <span class="mi">4111111111</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="no">A</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">a</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min</span>
<span class="p">}</span>
<span class="n">func</span> <span class="n">minDistance</span><span class="p">(</span><span class="n">word1</span> <span class="n">string</span><span class="p">,</span> <span class="n">word2</span> <span class="n">string</span><span class="p">)</span> <span class="n">int</span> <span class="p">{</span>
    <span class="no">I</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)</span>
    <span class="no">J</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">word2</span><span class="p">)</span>
    <span class="sr">//</span><span class="no">Dij</span> <span class="n">represents</span> <span class="n">the</span> <span class="n">edit</span> <span class="n">distance</span> <span class="n">between</span> <span class="n">word1</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">word2</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span>
    <span class="nf">/</span><span class="o">/</span><span class="no">Do</span> <span class="no">D0j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="no">Di0</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">edit</span> <span class="n">distance</span> <span class="n">between</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">an</span> <span class="n">empty</span> <span class="n">string</span> <span class="n">is</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>
    <span class="no">D</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][]</span><span class="n">int</span><span class="p">,</span> <span class="no">I</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="no">D</span> <span class="p">{</span>
        <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">int</span><span class="p">,</span> <span class="no">J</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="no">D</span> <span class="p">{</span>
        <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="no">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="no">D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">I</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="no">J</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">word1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
                <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="no">D</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">D</span><span class="p">[</span><span class="no">I</span><span class="p">][</span><span class="no">J</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure>


  </div><a class="u-url" href="/blog/2017/04/17/intro-to-dynamic-programming.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Vishnu Raghavan</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Vishnu Raghavan</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rvishpr"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">rvishpr</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my thoughts on what I&#39;ve been doing recently and anything I&#39;ve learned that I&#39;d like to document.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
